# go面试题

> new和make的区别？

首先划分两者可用的内置类型:

* make可用与`channl`,`map`,`slice`等引用类型
* new使用范围比较广泛，多数内置数据类型都可以使用。

**new 的作用是初始化一个指向类型的指针`(*T)`new\(T\)分配了零值填充的T类型的内存空间，并且返回其 地址，即一个\*T类型的值。**

**make 的作用是为 slice，map 或 chan 初始化并返回一个有初始值\(非零\)的引用\(T\)类型**

**共同点：** 都是可以作为某种数据类型进行初始化。也就是申请内存空间并用变量存储返回。

**不同点:** `new`返回的是初始化类型的指针，`make`返回的是类型的引用。

```go
// make关键字
map:=make(map[int]string,0)
slice:=make([]int,0)
channel:=make(chan int,5)

// new关键字
i:=new(int)  // 变量i中保存着指向int类型的指针
var v int
i := &v
```

`new(T)`为每个类型T分配一片内存地址（根据不同类型对内存字节数占用大小进行分配\)，并初始化为对应T类型的默认初始化值。返回一个\*T内存起始地址。

`make(T)`它只适用于3种内建的引用类型：切片、map 和 channel，返回一个T类型初始值。（编译器对make关键字有处理）

**实现原理分析：**

主要可以从`运行时`和`编译期间`两个不同阶段去理解。

* **make**

  在go源代码编译过程中，其实会将整个源文件载入解析成AST抽象语法树，然后根据语法树进行编译处理。 在编译期间的 类型检查 阶段，Go 语言其实就将代表 `make` 关键字的 `OMAKE` 节点根据参数类型的不同转换成了 `OMAKESLICE`、`OMAKEMAP` 和 `OMAKECHAN` 三种不同类型的节点，这些节点最终也会调用不同的运行时函数来初始化数据结构。（此处的节点应该就是AST中的树节点）

* **new**

  内置函数 `new` 会在编译期间的 SSA 代码生成 阶段经过 `callnew` 函数的处理，如果请求创建的类型大小时 0，那么就会返回一个表示空指针的 `zerobase` 变量，在遇到其他情况时会将关键字转换成 `newobject`,`newobject` 函数的工作就是获取传入类型的大小并调用 `mallocgc` 在堆上申请一片大小合适的内存空间并返回指向这片内存空间的指针：

  ```go
  func newobject(typ *_type) unsafe.Pointer {
      return mallocgc(typ.size, typ, true)
  }
  ```

总结：

```go
适用范围：make 只能创建内建类型(slice map channel)， new 则是可以对所有类型进行内存分配
返回值： new 返回指针， make 返回引用
填充值： new 填充零值， make 填充非零值
```

> golang内置的引用类型有那些？

引用类型：引用类型有 切片 \(`slice`\) 、 字典 \(`map`\) 、 接口 \(`interface`\) 、 函数 \(`func`\) 以及 通道 \(`chan`\)

> 将10阶对称矩阵压缩存储到一维数组A中，则数组A的长度最少为?

根据对称矩阵对角线两侧元素相同的性质\(**aij=aji**\)，最少的情况下，对角线保存一部分，以对角线为对称轴的两侧只保存一侧即可，故n阶对称矩阵只需要保存上三角或下三角，求和`1+2+...+n=(n(n+1))/2`.

> golang 中 select 的多个 case 同时成立，那么选择的是哪一个?
>
> golang 中除了使用 sync 锁，还可以如何保证并发安全? atomic 是什么？
>
> sync.Map 对键的类型有什么要求么？
>
> 如何避免死锁? golang 中如何检测死锁?
>
> 如何更好的用pprof定位内存泄漏?
>
> [https://lrita.github.io/2017/05/26/golang-memory-pprof/](https://lrita.github.io/2017/05/26/golang-memory-pprof/)

```text
分布式架构
    架构演进
        为什么需要分布式架构？
            大流量保护
                集群分流并发请求，负载均衡
            关键业务保护
                故障隔离，业务降级
    架构技术
        如何提高架构性能？
            缓存
                缓存区域
                    前端缓存
                    后端缓存
                    数据库缓存
                缓存系统
                    缓存分区
                    缓存更新
                    缓存命中
            负载均衡
                水平拓展
                    增加机器分流
                网关系统
                    负载均衡
                    服务路由
                    服务发现
            异步调用
                异步系统
                    消息队列
                        削峰流量，请求排队
                    消息持久化
                    异步事务
                异步通讯三种方式
                    请求响应式
                        请求方调用接收方，返回请求，请求方轮训或者接收方回调请求方
                    订阅模式
                        通过订阅队列将信息发送方和消费方解耦
                    broker方式
                        消息中间件
                            必须高可用
                            可水平拓展
                            可持久化不丢失数据
                好处？
                    解耦服务间的依赖
                    故障隔离
                    提高吞吐量
            数据镜像
                数据同步
                    主从延迟
                读写分离
                数据一致性
            数据分区
                分区策略
                数据访问层
                数据一致性
            高性能
        如何提高架构稳定性
            服务拆分
                目的
                    隔离故障
                    服务复用
                    服务调用依赖问题
                服务调用
                服务依赖
                服务隔离
            服务冗余
                目的
                    去除单点故障
                    支持服务弹性伸缩
                        数据复制/重新分片
                    故障迁移
                        数据迁移
            限流降级
                目的
                    保护系统被大量并发请求弄垮
                实现思路
                    限流
                        令牌桶算法
                        漏斗算法
                    降级
                        停掉部分服务，拒绝部分用户请求
                实现方式
                    异步队列
                    降级控制
                    服务熔断
            高可用架构
                目的
                    避免出现单点故障
                多租户系统
                灾备多活
                集群
            高可用
        全栈系统监控
            基础层
                监控主机和底层资源
                    CPU，内存，网络吞吐，磁盘IO..
            平台层（中间层）
                Nginx,Redis,Kafka,Mysql..
            应用层
                HTTP访问吞吐量，RT，返回码，调用链路监控..
                埋点
    容错设计（弹力设计）
        系统可用性
            如何度量系统可用性，有那些指标
        系统宕机
            无计划的
                系统级故障
            有计划的
                日常维护
                    备份，容量规划
                运维相关
                    数据库维护，应用维护，中间件...
        系统问题分类
            网络问题
                网络连接，宽带..
            性能问题
                数据库慢SQL，Full GC，硬盘IO过大，CPU飙高，内存不足
            安全问题
                网络攻击
            运维问题
        服务的状态
            什么是服务中的状态？
                保留程序的一些数据或者上下文
                    程序接口处理过程中数据保存
                具象化
                    程序调用的结果
                    服务组合的上下文
                    服务的配置
            什么是无状态的？
                函数式编程
                http请求
                    因为无状态所以产生session/cookies
```

